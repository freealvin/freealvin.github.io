<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Alvin]]></title>
  <link href="http://freealvin.github.io/atom.xml" rel="self"/>
  <link href="http://freealvin.github.io/"/>
  <updated>2014-07-24T00:11:21+08:00</updated>
  <id>http://freealvin.github.io/</id>
  <author>
    <name><![CDATA[Alvin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C语言的缩进和空白]]></title>
    <link href="http://freealvin.github.io/blog/2013/12/02/cyu-yan-de-suo-jin-he-kong-bai/"/>
    <updated>2013-12-02T21:31:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/12/02/cyu-yan-de-suo-jin-he-kong-bai</id>
    <content type="html"><![CDATA[<p>C语言的缩进和空白使用原则</p>

<!--more-->


<h1>一般编码缩进规则</h1>


<p>1.字if、while、for与其后的控制表达式的(括号之间插入一个空格分隔，但括号内的表达式应紧贴括号
例如
<code> while (1) </code>
2.双目运算符的两侧各插入一个空格分隔，单目运算符和操作数之间不加空格
例如：
<code>i␣=␣i␣+␣1、++i、!(i␣&lt;␣1)、-x、&amp;a[1]等)</code></p>

<p>3.后缀运算符和操作数之间也不加空格
例如:
取结构体成员<code>s.a</code>、函数调用<code>foo(arg1)</code>、取数组成员<code>a[i]</code></p>

<ol>
<li><p>,号和;号之后要加空格，这是英文的书写习惯
例如：
<code>for␣(i␣=␣1;␣i␣&lt;␣10;␣i++)、foo(arg1,␣arg2)</code></p></li>
<li><p>有时候为了突出优先级也可以写得更紧凑一些
例如：
<code>for␣(i=1;␣i&lt;10;␣i++)</code>、<code>distance␣=␣sqrt(x<em>x␣+␣y</em>y)</code>等。但是省略的空格一定不要误导了读代码的人，例如<code>a||b␣&amp;&amp;␣c</code>很容易让人理解成错误的优先级.</p></li>
<li><p>接近或大于80个字符的较长语句要折行写
由于UNIX系统标准的字符终端是24行80列的，接近或大于80个字符的较长语句要折行写，折行后用空格和上面的表达式或参数对齐，例如：</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if␣(sqrt(x*x␣+␣y*y)␣>␣5.0
</span><span class='line'>    &&␣x␣&lt;␣0.0
</span><span class='line'>    &&␣y␣>␣0.0)</span></code></pre></td></tr></table></div></figure>


<p>再比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>foo(sqrt(x*x␣+␣y*y),
</span><span class='line'>    a[i-1]␣+␣b[i-1]␣+␣c[i-1])</span></code></pre></td></tr></table></div></figure>


<ol>
<li>较长的字符串可以断成多个字符串然后分行书写
例如:</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>printf("This is such a long sentence that "
</span><span class='line'>       "it cannot be held within a line\n");</span></code></pre></td></tr></table></div></figure>


<p>C编译器会自动把相邻的多个字符串接在一起，以上两个字符串相当于一个字符串&#8221;This is such a long sentence that it cannot be held within a line\n&#8221;。</p>

<ol>
<li>在变量定义语句中用Tab字符，使变量名对齐
有的人喜欢在变量定义语句中用Tab字符，使变量名对齐，这样看起来很美观。</li>
</ol>


<h1>内核编码缩进规则</h1>


<p>1.要用缩进体现出语句块的层次关系
要用缩进体现出语句块的层次关系，使用Tab字符缩进，不能用空格代替Tab。在标准的字符终端上一个Tab看起来是8个空格的宽度，如果你的文本编辑器可以设置Tab的显示宽度是几个空格，建议也设成8，这样大的缩进使代码看起来非常清晰。如果有的行用空格做缩进，有的行用Tab做缩进，甚至空格和Tab混用，那么一旦改变了文本编辑器的Tab显示宽度就会看起来非常混乱，所以内核代码风格规定只能用Tab做缩进，不能用空格代替Tab。</p>

<ol>
<li>语句块的{或}应该和关键字写在同一行，用空格隔开，而不是单独占一行
if/else、while、do/while、for、switch这些可以带语句块的语句，语句块的{或}应该和关键字写在同一行，用空格隔开，而不是单独占一行。例如应该这样写：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if␣(...)␣{
</span><span class='line'>       →语句列表
</span><span class='line'>}␣else␣if␣(...)␣{
</span><span class='line'>       →语句列表
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>但很多人习惯这样写：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if␣(...)
</span><span class='line'>{
</span><span class='line'>    →语句列表
</span><span class='line'>}
</span><span class='line'>else␣if␣(...)
</span><span class='line'>{
</span><span class='line'>    →语句列表
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>内核的写法和[K&amp;R]一致，好处是不必占太多行，使得一屏能显示更多代码。这两种写法用得都很广泛，只要在同一个项目中能保持统一就可以了。</p>

<ol>
<li>函数定义的{和}单独占一行，这一点和语句块的规定不同</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int␣foo(int␣a,␣int␣b)
</span><span class='line'>{
</span><span class='line'>    →语句列表
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>switch和语句块里的case、default对齐写
switch和语句块里的case、default对齐写，也就是说语句块里的case、default标号相对于switch不往里缩进，但标号下的语句要往里缩进。例如：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>→switch␣(c)␣{
</span><span class='line'>→case 'A':
</span><span class='line'>→       →语句列表
</span><span class='line'>→case 'B':
</span><span class='line'>→       →语句列表
</span><span class='line'>→default:
</span><span class='line'>→       →语句列表
</span><span class='line'>→}</span></code></pre></td></tr></table></div></figure>


<p>用于goto语句的自定义标号应该顶头写不缩进，而不管标号下的语句缩进到第几层。</p>

<ol>
<li>代码中每个逻辑段落之间应该用一个空行分隔开
例如每个函数定义之间应该插入一个空行，头文件、全局变量定义和函数定义之间也应该插入空行，例如：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h>
</span><span class='line'>#include &lt;stdlib.h>
</span><span class='line'>
</span><span class='line'>int g;
</span><span class='line'>double h;
</span><span class='line'>
</span><span class='line'>int foo(void)
</span><span class='line'>{
</span><span class='line'>    →语句列表
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int bar(int a)
</span><span class='line'>{
</span><span class='line'>    →语句列表
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main(void)
</span><span class='line'>{
</span><span class='line'>    →语句列表
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>一个函数的语句列表如果很长，也可以根据相关性分成若干组，用空行分隔。
一个函数的语句列表如果很长，也可以根据相关性分成若干组，用空行分隔。这条规定不是严格要求，通常把变量定义组成一组，后面加空行，return语句之前加空行，例如：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int main(void)
</span><span class='line'>{
</span><span class='line'>    →int    →a, b;
</span><span class='line'>    →double →c;
</span><span class='line'>
</span><span class='line'>    →语句组1
</span><span class='line'>
</span><span class='line'>    →语句组2
</span><span class='line'>
</span><span class='line'>     →return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AT&amp;T汇编语法2]]></title>
    <link href="http://freealvin.github.io/blog/2013/12/02/at-and-thui-bian-yu-fa-2/"/>
    <updated>2013-12-02T08:45:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/12/02/at-and-thui-bian-yu-fa-2</id>
    <content type="html"><![CDATA[<ol>
<li>内联汇编</li>
</ol>


<!--more-->


<p>（一）内联汇编
参考<a href="http://www.ibm.com/developerworks/cn/linux/sdk/assemble/inline/">Linux中x86的内联汇编</a></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>asm (assembler template
</span><span class='line'>    
</span><span class='line'>    : output operands               (optional)
</span><span class='line'>    : input operands                (optional)
</span><span class='line'>    : list of clobbered registers   
</span><span class='line'>    (optional)                
</span><span class='line'>);</span></code></pre></td></tr></table></div></figure>


<p> 汇编程序模板由汇编指令组成。输入操作数是充当指令输入操作数使用的 C 表达式。输出操作数是将对其执行汇编指令输出的 C 表达式。</p>

<h2>内敛汇编的基本要素</h2>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    int a=10, b;
</span><span class='line'>        asm ("movl %1, %%eax;
</span><span class='line'>            movl %%eax, %0;"
</span><span class='line'>            :"=r"(b)  /* output */    
</span><span class='line'>            :"r"(a)       /* input */
</span><span class='line'>            :"%eax"); /* clobbered register */
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>·&#8221;b&#8221;是输出操作数,由%0引用,&ldquo;a&#8221;是输入操作数,由%1引用<br/>
·&#8221;r&#8221;是操作数的约束,它指定将变量&#8221;a&#8221;和&#8221;b&#8221;存储在寄存器中。输出操作数约束应该带有一个约束修饰符&rdquo;=&ldquo;,表示它是输出操作数<br/>
·要在&#8221;asm&#8221;内使用寄存器%eax,%eax的前面应该再加一个%,换句话说是%%eax，因为&#8221;asm&#8221;使用%0、%1等来表示变量。任何带有一个%的数都看做是输入/输出操作数,而不认为是寄存器<br/>
·第三个冒号后的修饰寄存器%eax告诉将在asm中修改GCC%eax的值，这样GCC就不适用该寄存器存储任何其它的值<br/>
·movl %1, %%eax将&#8221;a&#8221;的值移到%eax中, movl %%eax, %0将%eax的内容移到&#8221;b&#8221;中<br/>
·因为&#8221;b&#8221;被指定成输出操作数,因此当&#8221;asm&#8221;的执行完成后，它将反映出更新的值。换句话说,对&#8221;asm&#8221;内&#8221;b&#8221;所做的更改将在&#8221;asm&#8221;外反映出来</p>

<h2>汇编程序模板</h2>


<p>汇编程序模板是一组插入到 C 程序中的汇编指令（可以是单个指令，也可以是一组指令）。每条指令都应该由双引号括起，或者整组指令应该由双引号括起。每条指令还应该用一个定界符结尾。有效的定界符为新行 (\n) 和分号 (;)。 &lsquo;\n&rsquo; 后可以跟一个 tab(\t) 作为格式化符号，增加 GCC 在汇编文件中生成的指令的可读性。 指令通过数 %0、%1 等来引用 C 表达式（指定为操作数）。</p>

<p>如果希望确保编译器不会在 &ldquo;asm&rdquo; 内部优化指令，可以在 &ldquo;asm&rdquo; 后使用关键字 &ldquo;volatile&#8221;。如果程序必须与 ANSI C 兼容，则应该使用 <strong>asm</strong> 和 <strong>volatile</strong>，而不是 asm 和 volatile</p>

<h2>操作数</h2>


<p>C 表达式用作 &ldquo;asm&rdquo; 内的汇编指令操作数。在汇编指令通过对 C 程序的 C 表达式进行操作来执行有意义的作业的情况下，操作数是内联汇编的主要特性。</p>

<p>每个操作数都由操作数约束字符串指定，后面跟用括弧括起的 C 表达式，例如：&#8221;constraint&#8221; (C expression)。操作数约束的主要功能是确定操作数的寻址方式。</p>

<p>可以在输入和输出部分中同时使用多个操作数。每个操作数由逗号分隔开。</p>

<p>在汇编程序模板内部，操作数由数字引用。如果总共有 n 个操作数（包括输入和输出），那么第一个输出操作数的编号为 0，逐项递增，最后那个输入操作数的编号为 n -1。总操作数的数目限制在 10，如果机器描述中任何指令模式中的最大操作数数目大于 10，则使用后者作为限制。</p>

<h2>修饰寄存器列表</h2>


<p>如果 &ldquo;asm&rdquo; 中的指令指的是硬件寄存器，可以告诉 GCC 我们将自己使用和修改它们。这样，GCC 就不会假设它装入到这些寄存器中的值是有效值。通常不需要将输入和输出寄存器列为 clobbered，因为 GCC 知道 &ldquo;asm&rdquo; 使用它们（因为它们被明确指定为约束）。不过，如果指令使用任何其它的寄存器，无论是明确的还是隐含的（寄存器不在输入约束列表中出现，也不在输出约束列表中出现），寄存器都必须被指定为修饰列表。修饰寄存器列在第三个冒号之后，其名称被指定为字符串。</p>

<p>至于关键字，如果指令以某些不可预知且不明确的方式修改了内存，则可能将 &ldquo;memory&rdquo; 关键字添加到修饰寄存器列表中。这样就告诉 GCC 不要在不同指令之间将内存值高速缓存在寄存器中。</p>

<h2>操作数约束</h2>


<p>前面提到过，&#8221;asm&#8221; 中的每个操作数都应该由操作数约束字符串描述，后面跟用括弧括起的 C 表达式。操作数约束主要是确定指令中操作数的寻址方式。约束也可以指定：
1. 是否允许操作数位于寄存器中，以及它可以包括在哪些种类的寄存器中
2. 操作数是否可以是内存引用，以及在这种情况下使用哪些种类的地址
3. 操作数是否可以是立即数
约束还要求两个操作数匹配。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AT&amp;T汇编语言学习1]]></title>
    <link href="http://freealvin.github.io/blog/2013/11/27/at-and-thui-bian-yu-yan-xue-xi-1/"/>
    <updated>2013-11-27T09:14:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/11/27/at-and-thui-bian-yu-yan-xue-xi-1</id>
    <content type="html"><![CDATA[<!--more-->


<h1>一. AT&T汇编语法格式</h1>


<p>(1) 寄存器引用</p>

<pre><code>引用寄存器要在寄存器号前加%，如move %eax, %ebx
</code></pre>

<p>(2) 操作数顺序</p>

<pre><code>操作数排列是从源（左）到目的（右）， 如
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>move %eax, %ebx
</span><span class='line'># %eax为源, %ebx为目的地址</span></code></pre></td></tr></table></div></figure>


<p>(3) 常数/立即数的格式<br/></p>

<pre><code>使用立即数，要在数前加$，如mov $4, %ebx 
符号常数直接引用 如mov value, %ebx
引用符号地址在符号前加$，如mov $value, %ebx
</code></pre>

<p>(4) 操作数的长度<br/></p>

<pre><code>操作数的长度用加在指令后的符号表示
b(byte)
w(word)
l(long)
如：mov w%ax, %bx
</code></pre>

<h1>二. 转移和调用</h1>


<p>
(1) 在AT&amp;T汇编格式中，绝对转移和调用指令(jmp/call)的操作数前 要加上&#8217;*&lsquo;作为前缀<br/>
(2) 远转移指令和远调用指令的操作码，在AT&amp;T汇编格式中为&#8221;ljump&#8221;和&#8221;lcall&#8221;,在Itel汇编格式中则为&#8221;jmp far&#8221;和&#8221;call far&#8221;<br/></p>

<p>AT&amp;T格式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ljump $section, $offset
</span><span class='line'>lcall $section, $offset</span></code></pre></td></tr></table></div></figure>


<p>Intel格式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>jump far section:offset
</span><span class='line'>call far section:offset</span></code></pre></td></tr></table></div></figure>


<p>(3) 远程返回指令<br/></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lret $stack_adjust
</span><span class='line'>ret far stack_adjust</span></code></pre></td></tr></table></div></figure>


<p>(4) 寻址方式<br/></p>

<pre><code>用section:disp(base, index, scale)表示，计算方法是:
    base + index*scale + disp

section:[base+index*scale+disp] #Intel
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>movl -4(%ebp), %eax                    mov eax, [ebp-4]
</span><span class='line'>movl array(, %eax, 4), %eax            mov eax, [eax*4+array]
</span><span class='line'>movw array(%ebx, %eax, 4), %cx         mov cx, [ebx+4*eax+array]
</span><span class='line'>movb $4, %fs:(%eax)                    mov fs:eax, 4</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux中的正则表达式]]></title>
    <link href="http://freealvin.github.io/blog/2013/11/26/linuxzhong-de-zheng-ze-biao-da-shi/"/>
    <updated>2013-11-26T20:09:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/11/26/linuxzhong-de-zheng-ze-biao-da-shi</id>
    <content type="html"><![CDATA[<!--more about 正则表达式-->




<h1>正则表达式</h1>


<br />


<pre><code>正则表达式完成字符串的匹配搜索，在Unix系统中，sed、grep、vi等工具都是用regexp规则。

(1) 正则表达式的基本语法

                   | 符号            | 含义                                       | 举例                 | 匹配                       |
                   | --------------- | ----------------------------------------   | -------------------- | -------------------------- |
                   | .               | 任何字符                                   | a..                  | a后面有两个字符的字符串    |
                   | ?               | 修饰匹配次数，0次或1次                     | x?                   | 0个或1个x                  |
                   | ^               | 匹配行首                                   | ^word                | 位于行首的word             |
                   | +               | 重复一次或多次                             | y+                   | 一个--或多个连续的y          |
                   | $               | 行尾                                       | x$                   | 以x结尾的行                |
                   | *               | 重复0次或多次                              | w.*s                 | 以w开头、s结尾的任何字符串 |
                   | [字符表]        | 字符表中的任一字符                         | [tT]                 | 小写字母t或大写字母T       |
                   | [!字符表]       | 匹配不属于范围指定内的字符                 | [!a-z]               | 匹配不是小写字母的字符     |
                   | [^字符表]       | 任一不在字符表中的字符                     | [^a-z A-Z]           | 任何非字母                 |
                   | \               | 转义字符                                   | \\n                  | 匹配换行符                 |
                   | \{min,max\}     | 前导正则表达式最少重复min次，最多重复max次 | x\{1,5\}             | 最少1个最多5个x            |
                   | \(...\)         | 将圆括号中匹配的字符串存储到下一个寄存器中 | \(more\)and\1        | 匹配more and more          |
                   | 表达式|1表达式2 | 匹配表达式1或表达式2                       | hello| happy         | 匹配hello或happy           |
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails With Mongodb]]></title>
    <link href="http://freealvin.github.io/blog/2013/11/18/ruby-on-rails-with-mongodb/"/>
    <updated>2013-11-18T00:35:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/11/18/ruby-on-rails-with-mongodb</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[把cs50.h添加到库中]]></title>
    <link href="http://freealvin.github.io/blog/2013/10/11/ba-cs50-dot-htian-jia-dao-ku-zhong/"/>
    <updated>2013-10-11T23:25:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/10/11/ba-cs50-dot-htian-jia-dao-ku-zhong</id>
    <content type="html"><![CDATA[<p>  我最近在看网易公开课CS50，自我感觉非常喜欢David J. Malan的教学方法，非常羡慕和感慨哈佛学生的大学学习环境。也感谢网易为广大中国学生带来的福利。</p>

<p>  以下是自己网上搜素总结的如何模仿搭建CS50中Malan使用的开发环境。</p>

<p>  <!--more-->
1. 参考<a href="https://manual.cs50.net/library/"> CS50 Manual</a>，选择适合自己的安装方法
我的是Centos，所以执行以下命令，安装cs50库</p>

<pre><code>&lt;div class='bogus-wrapper'&gt;&lt;notextile&gt;&lt;figure class='code'&gt;&lt;div class="highlight"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre class="line-numbers"&gt;&lt;span class='line-number'&gt;1&lt;/span&gt;
</code></pre>

<p><span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>yum -y install gcc
</span><span class='line'>      wget <a href="http://mirror.cs50.net/library50/c/library50-c-5.zip">http://mirror.cs50.net/library50/c/library50-c-5.zip</a>
</span><span class='line'>      unzip library50-c-5.zip
</span><span class='line'>      rm -f library50-c-5.zip
</span><span class='line'>      cd library50-c-5
</span><span class='line'>      gcc -c -ggdb -std=c99 cs50.c -o cs50.o
</span><span class='line'>      ar rcs libcs50.a cs50.o
</span><span class='line'>      chmod 0644 cs50.h libcs50.a
</span><span class='line'>      mkdir -p /usr/local/include
</span><span class='line'>      chmod 0755 /usr/local/include
</span><span class='line'>      mv -f cs50.h /usr/local/include
</span><span class='line'>      mkdir -p /usr/local/lib
</span><span class='line'>      chmod 0755 /usr/local/lib
</span><span class='line'>      mv -f libcs50.a /usr/local/lib
</span><span class='line'>      rm -rf library50-c-5</span></code></pre></td></tr></table></div></figure></notextile></div>
  2. 安装完cs50库后, 修改make选项</p>

<pre><code>修改~/.bashrc文件
在文件末尾添加
</code></pre>

<p>   <figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># configure gcc
</span><span class='line'>    export CC=gcc
</span><span class='line'>    export CFLAGS=&ldquo;-ggdb -std=c99 -Wall -Werror -Wformat=0&rdquo;
</span><span class='line'>    export LANG=C
</span><span class='line'>    export LDLIBS=&ldquo;-lcs50 -lm&rdquo;
</span><span class='line'>    alias gcc=&ldquo;gcc $CFLAGS&rdquo;</span></code></pre></td></tr></table></div></figure>
  3. 执行source ~/.bashrc使更改后的bashrc文件生效</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[递归与分治策略之整数划分]]></title>
    <link href="http://freealvin.github.io/blog/2013/09/18/di-gui-yu-fen-zhi-ce-lue-zhi-zheng-shu-hua-fen/"/>
    <updated>2013-09-18T10:49:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/09/18/di-gui-yu-fen-zhi-ce-lue-zhi-zheng-shu-hua-fen</id>
    <content type="html"><![CDATA[<p>  将正整数划分为一些列正整数之和。在正整数n的所有不同的划分中，将最大加数n1不大于m的划分个数记为q(n, m).可以建立q(n, m)的递归关系。</p>

<!--more-->


<ol>
<li> q(n,1) = 1, n>=1</li>
<li> q(n,m) = q(n,n) m>=n</li>
<li> q(n,n) = 1+q(n,n-1)</li>
<li> q(n,m) = q(n, n-1)+q(n-m, m), n>m>1：正整数n的最大加数不大于m的划分可以分成最大加数为m的划分和最大加数小于等于m-1的划分。</li>
</ol>


<p>有递归关系可以写出递归函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="nf">q</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">||</span><span class="n">m</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="o">||</span><span class="n">m</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&lt;</span><span class="n">m</span><span class="p">)</span>         <span class="k">return</span> <span class="n">q</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="n">m</span><span class="p">)</span>        <span class="k">return</span> <span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">q</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">q</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何从零开始学会 Ruby on Rails]]></title>
    <link href="http://freealvin.github.io/blog/2013/08/28/ru-he-cong-ling-kai-shi-xue-hui-ruby-on-rails/"/>
    <updated>2013-08-28T15:53:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/08/28/ru-he-cong-ling-kai-shi-xue-hui-ruby-on-rails</id>
    <content type="html"><![CDATA[<!--more-->


<p>来自<a href="http://huacnlee.com/blog/how-to-start-learning-ruby-on-rails/">http://huacnlee.com/blog/how-to-start-learning-ruby-on-rails/</a>
以下步骤请一步一步来，切勿心急跳过，最好连我上面的链接都不要提前点击！
1.安装 Linux 或 Mac， 开发工具使用 Windows &amp; Linux &ndash;> Sublime Text 2, Mac &ndash;> TextMate 2 当然你也可以用 Vim 或 Sublime text 2;</p>

<p>2.安装 Ruby 和 Rails 开发环境可以按照这个流程：《如何快速正确的安装 Ruby, Rails》;</p>

<p>3.看完 <a href="http://guides.rubyonrails.org">http://guides.rubyonrails.org</a> 这里有 繁体版本；</p>

<p>4.通过学习 Rails Guides 实现一个博客系统，包涵完整的功能(包括 UI)，预计两周；</p>

<p>5.从头到尾一字不漏的看完 《应用 Rails 进行敏捷 Web 开发》；</p>

<p>6.回头审视之前的博客设计和《应用 Rails 进行敏捷 Web 开发》的区别，可以再重新搞个博客;</p>

<p>7.看完 《Getting Real》,预计两个小时；</p>

<p>8.搞明白 Gem, RVM, Bundler 是什么；</p>

<p>9.看完 《Rework》；</p>

<p>10.学习 Git, 上 <a href="http://github.com">http://github.com</a> 并长期使用；</p>

<p>11.看 <a href="http://railscasts.com">http://railscasts.com</a> 的视频教程，从 第一页 开始看，可以学到很多技巧，以免走弯路。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windows下Python安装模块]]></title>
    <link href="http://freealvin.github.io/blog/2013/08/27/windowsxia-pythonan-zhuang-mo-kuai/"/>
    <updated>2013-08-27T17:39:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/08/27/windowsxia-pythonan-zhuang-mo-kuai</id>
    <content type="html"><![CDATA[<!--more-->


<p>以安装Beautifulsoup4为例：</p>

<p>1.到网站上下载：<a href="http://www.crummy.com/software/BeautifulSoup/bs4/download/">http://www.crummy.com/software/BeautifulSoup/bs4/download/</a></p>

<p>2.解压文件到C:\Python27</p>

<p>3.cmd运行C:\Python27\BeautifulSoup>python setup.py install</p>

<p>4.注意库名：creating build\lib\bs4</p>

<p>5.测试一下是否能导入：</p>

<blockquote><blockquote><blockquote><p>import bs4</p></blockquote></blockquote></blockquote>

<p>如果不能导入，会提示：ImportError: No module named bs4</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重载运算符++]]></title>
    <link href="http://freealvin.github.io/blog/2013/08/23/zhong-zai-yun-suan-fu-plus-plus/"/>
    <updated>2013-08-23T13:19:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/08/23/zhong-zai-yun-suan-fu-plus-plus</id>
    <content type="html"><![CDATA[<p>自定义重载运算符++时，为了区分前++和后++，在重载后++时添加哑参数。</p>

<!--more-->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="n">F</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">(){</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">F</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">){</span><span class="c1">//此处使用到哑元</span>
</span><span class='line'>      <span class="n">F</span> <span class="n">old</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">old</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>由上可知，自定义重载的++运算符，前++往往比后++效率高，所以一般选择使用前++</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Dict]]></title>
    <link href="http://freealvin.github.io/blog/2013/08/22/python-dict/"/>
    <updated>2013-08-22T13:07:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/08/22/python-dict</id>
    <content type="html"><![CDATA[<h1>dict</h1>

<p>字典的用法，dict的查找特别快捷。如果我们的项目经常用到搜索某些数据，最好用dict类型。</p>

<!--more-->


<h2>创建dict</h2>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">dict1</span> <span class="o">=</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sape</span><span class="o">=</span><span class="mi">4139</span><span class="p">,</span> <span class="n">guido</span><span class="o">=</span><span class="mi">4127</span><span class="p">,</span> <span class="n">jack</span><span class="o">=</span><span class="mi">4098</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span><span class="s">&#39;sape&#39;</span><span class="p">:</span> <span class="mi">4139</span><span class="p">,</span> <span class="s">&#39;jack&#39;</span><span class="p">:</span> <span class="mi">4098</span><span class="p">,</span> <span class="s">&#39;guido&#39;</span><span class="p">:</span> <span class="mi">4127</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者用dict构造函数创建dict变量</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">dict2</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">key1</span><span class="p">,</span> <span class="n">value1</span><span class="p">),(</span><span class="n">key2</span><span class="p">,</span><span class="n">value2</span><span class="p">),</span><span class="o">...</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>表达式创建</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">dict3</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)}</span>
</span><span class='line'><span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span> <span class="mi">36</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<h2>添加元素</h2>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">tel</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'><span class="c">#dict1[key] = value</span>
</span><span class='line'><span class="n">tel</span><span class="p">[</span><span class="s">&#39;guido&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4127</span>
</span><span class='line'><span class="n">tel</span><span class="p">[</span><span class="s">&#39;jack&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4098</span>
</span><span class='line'><span class="n">tel</span><span class="p">[</span><span class="s">&#39;sape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4193</span>
</span></code></pre></td></tr></table></div></figure>




<h2>获取元素值</h2>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">num1</span> <span class="o">=</span> <span class="n">tel</span><span class="p">[</span><span class="s">&#39;sape&#39;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果键不存在，tel[key]操作会出错，所以在获取元素之前，需要判断元素键是否存在
判断方法？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'>   <span class="k">if</span> <span class="n">tel</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;snape&quot;</span><span class="p">):</span>
</span><span class='line'>      <span class="n">num1</span> <span class="o">=</span> <span class="n">tel</span><span class="p">[</span><span class="s">&quot;snape&quot;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'>   <span class="k">if</span> <span class="s">&quot;snape&quot;</span> <span class="ow">in</span> <span class="n">tel</span><span class="p">:</span>
</span><span class='line'>      <span class="n">num1</span> <span class="o">=</span> <span class="n">tel</span><span class="p">[</span><span class="s">&quot;snape&quot;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>




<h2>删除元素</h2>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">del</span> <span class="n">tel</span><span class="p">[</span><span class="s">&quot;guido&quot;</span><span class="p">]</span>
</span><span class='line'><span class="c">#tel.pop(&quot;jack&quot;)</span>
</span></code></pre></td></tr></table></div></figure>




<h2>遍历</h2>


<p>迭代器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">knights</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;gallahad&#39;</span><span class="p">:</span> <span class="s">&#39;the pure&#39;</span><span class="p">,</span> <span class="s">&#39;robin&#39;</span><span class="p">:</span> <span class="s">&#39;the brave&#39;</span><span class="p">}</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">knights</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
</span><span class='line'><span class="o">...</span>     <span class="k">print</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="n">gallahad</span> <span class="n">the</span> <span class="n">pure</span>
</span><span class='line'><span class="n">robin</span> <span class="n">the</span> <span class="n">brave</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python List]]></title>
    <link href="http://freealvin.github.io/blog/2013/08/22/python-list/"/>
    <updated>2013-08-22T12:18:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/08/22/python-list</id>
    <content type="html"><![CDATA[<p>list是python里非常强大的数据类型</p>

<!--more-->


<h2>list 复制</h2>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>>> l1=[1,2,3]
</span><span class='line'>>>> l2=l1
</span><span class='line'>>>> l1[0]=10
</span><span class='line'>>>> print l1
</span><span class='line'>[10, 2, 3]
</span><span class='line'>>>> print l2
</span><span class='line'>[10, 2, 3]
</span><span class='line'>>>></span></code></pre></td></tr></table></div></figure>




<h2>如何复制？</h2>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>>> l2=l1[:]
</span><span class='line'>>>> print l2
</span><span class='line'>[10, 2, 3]
</span><span class='line'>>>> l1[0]=24
</span><span class='line'>>>> print l1
</span><span class='line'>[24, 2, 3]
</span><span class='line'>>>> print l2
</span><span class='line'>[10, 2, 3]
</span><span class='line'>>>></span></code></pre></td></tr></table></div></figure>


<p>发生了什么？ 第一种是<strong>指向</strong>，其实还是同一个内容。 第二种是<strong>复制</strong>。</p>

<h2>本质上的区别</h2>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>>> l2 = l1
</span><span class='line'>>>> l2 == l1 #值相同
</span><span class='line'>True
</span><span class='line'>>>> l2 is l1 #指向同一个地方
</span><span class='line'>True
</span><span class='line'>>>> l2 = l1[:]
</span><span class='line'>>>> l2 == l1 #值相同
</span><span class='line'>True
</span><span class='line'>>>> l2 is l1 #并不是指向同一个地方
</span><span class='line'>False</span></code></pre></td></tr></table></div></figure>




<h2>list如何添加元素？</h2>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>>> l1=[]
</span><span class='line'>>>> l1[0]="a"
</span><span class='line'>Traceback (most recent call last):
</span><span class='line'>  File "&lt;stdin>", line 1, in &lt;module>
</span><span class='line'>IndexError: list assignment index out of range</span></code></pre></td></tr></table></div></figure>


<p>为什么？ 因为l1等于一个空列表，没有空间。 l1[0]是需要空间的。</p>

<p>我们该怎么让空list存储数据?</p>

<p>list有一写默认的函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>l1.append("a")</span></code></pre></td></tr></table></div></figure>




<h2>删除成员的方法</h2>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>>> l1.append("b")
</span><span class='line'>>>> l1.append("c")
</span><span class='line'>>>> l1.append("d")
</span><span class='line'>>>> l1.append("b")
</span><span class='line'>>>> print l1
</span><span class='line'>["b", "c", "d","b"]
</span><span class='line'>>>> l1.remove("b")
</span><span class='line'>>>> print l1
</span><span class='line'>["c", "d","b"]
</span><span class='line'>>>> l1.remove("b")
</span><span class='line'>>>> print l1
</span><span class='line'>["c","d"]</span></code></pre></td></tr></table></div></figure>


<p>还有</p>

<p>l1.pop()
再试一个删除的高级用法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>>> print l1
</span><span class='line'>[2, 3, 4, 5]
</span><span class='line'>>>> del l1[1:3]
</span><span class='line'>>>> print l1
</span><span class='line'>[2, 5]</span></code></pre></td></tr></table></div></figure>




<h2>如何插入一个元素：</h2>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>>>> l1.insert(1,67)
</span><span class='line'>>>> print l1
</span><span class='line'>[2, 67, 5]</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使同一个用户组的用户拥有一个目录的开发权]]></title>
    <link href="http://freealvin.github.io/blog/2013/08/20/ru-he-shi-tong-%5B%3F%5D-ge-yong-hu-zu-de-yong-hu-yong-you-%5B%3F%5D-ge-mu-lu-de-kai-fa-quan/"/>
    <updated>2013-08-20T06:17:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/08/20/ru-he-shi-tong-[?]-ge-yong-hu-zu-de-yong-hu-yong-you-[?]-ge-mu-lu-de-kai-fa-quan</id>
    <content type="html"><![CDATA[<!--more-->


<p>1.添加项目组
  <figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#groupadd poject</span></code></pre></td></tr></table></div></figure>
2.添加获得project支持的用户</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#useradd -G project alex
</span><span class='line'>     #useradd -G project arod</span></code></pre></td></tr></table></div></figure>


<p>3.创建目录</p>

<pre><code>&lt;div class='bogus-wrapper'&gt;&lt;notextile&gt;&lt;figure class='code'&gt;&lt;div class="highlight"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre class="line-numbers"&gt;&lt;span class='line-number'&gt;1&lt;/span&gt;
</code></pre>

<p></pre></td><td class='code'><pre><code class=''><span class='line'>#mkdir /srv/ahome</span></code></pre></td></tr></table></div></figure></notextile></div>
4.把目录的用户组改为project</p>

<pre><code>&lt;div class='bogus-wrapper'&gt;&lt;notextile&gt;&lt;figure class='code'&gt;&lt;div class="highlight"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre class="line-numbers"&gt;&lt;span class='line-number'&gt;1&lt;/span&gt;
</code></pre>

<p></pre></td><td class='code'><pre><code class=''><span class='line'>#chgrp project /srv/ahome</span></code></pre></td></tr></table></div></figure></notextile></div>
5.更改目录的权限，是project用户组可以rwx,其他人没有任何权限
  <figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#chmod 770 /srv/ahome</span></code></pre></td></tr></table></div></figure></p>

<p>6.切换到alex,并在/srv/ahome下创建一个文件，查看文件的权限</p>

<pre><code> &lt;div class='bogus-wrapper'&gt;&lt;notextile&gt;&lt;figure class='code'&gt;&lt;div class="highlight"&gt;&lt;table&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre class="line-numbers"&gt;&lt;span class='line-number'&gt;1&lt;/span&gt;
</code></pre>

<p><span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#su &ndash; alex
</span><span class='line'>     $touch abcd
</span><span class='line'>     $ll</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<pre><code> 会发现abcd 的拥有者、group均为alex,而arod虽然对文件夹有rwx权限，但对于刚刚创建的文件可以删除却不能编辑
</code></pre>

<p>7.这就要用到SGID</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$exit
</span><span class='line'>     #chomd 2770 /srv/ahome</span></code></pre></td></tr></table></div></figure>


<pre><code> 这样执行者在执行的过程中会自动获得该程序用户组的支持 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[拷贝构造函数与赋值运算符]]></title>
    <link href="http://freealvin.github.io/blog/2013/08/18/kao-bei-gou-zao-han-shu-yu-fu-zhi-yun-suan-fu/"/>
    <updated>2013-08-18T06:55:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/08/18/kao-bei-gou-zao-han-shu-yu-fu-zhi-yun-suan-fu</id>
    <content type="html"><![CDATA[<p>总结一下：拷贝构造函数会逐一复制成员，所以如果对象里有指针，那么默认拷贝构造函数只会复制指针的内容，而不会为新对象分配相应的动态空间（存储指针所指向的内容），这样导致了两个对象的数据成员指向同一个地址，在释放空间时，导致同一块空间被释放两次这样的错误。同样赋值也会逐一复制成员，有指针成员也会导致析构这样释放空间的操作时出现错误，所以一般需要重写拷贝构造函数的类，也需要重写“=”赋值运算符。</p>

<!--more-->




<h2>When do I need to write a copy constructor?</h2>


<p>First, you should understand that if you do not declare a copy constructor, the compiler gives you one implicitly. The implicit copy constructor does a member-wise copy of the source object.
For example, given the class:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class MyClass {
</span><span class='line'>      int x;
</span><span class='line'>      char c;
</span><span class='line'>      std::string s;
</span><span class='line'>  };</span></code></pre></td></tr></table></div></figure>


<p>the compiler-provided copy constructor is exactly equivalent to:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MyClass::MyClass( const MyClass& other ) :
</span><span class='line'>     x( other.x ), c( other.c ), s( other.s )
</span><span class='line'>  {}</span></code></pre></td></tr></table></div></figure>


<p>In many cases, this is sufficient. However, there are certain circumstances where the member-wise copy version is not good enough. By far, the most common reason the default copy constructor is not sufficient is because the object contains raw pointers and you need to take a &ldquo;deep&rdquo; copy of the pointer. That is, you don&rsquo;t want to copy the pointer itself; rather you want to copy what the pointer
points to. Why do you need to take &ldquo;deep&rdquo; copies? This is typically because the instance owns the pointer; that is, the instance is responsible for calling delete on the pointer at some point (probably the destructor). If two objects end up calling delete on the same non-NULL pointer, heap corruption results.</p>

<p>Rarely you will come across a class that does not contain raw pointers yet the default copy constructor is not sufficient. An example of this is when you have a reference-counted object.
boost::shared_ptr&lt;> is example.</p>

<h2>When do I need to write an assignment operator?</h2>


<p>First, you should understand that if you do not declare an assignment operator, the compiler gives you one implicitly. The implicit assignment operator does member-wise assignment of each data member from the source object. For example, using the class above, the compiler-provided assignment operator isexactly equivalent to:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MyClass& MyClass::operator=( const MyClass& rhs ) {
</span><span class='line'>      x = other.x;
</span><span class='line'>      c = other.c;
</span><span class='line'>      s = other.s;
</span><span class='line'>      return *this;
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>In general, any time you need to write your own custom copy constructor, you also need to write a custom assignment operator.
File /home/Alvin/git_projects/octopress/source/downloads/code/03copy_constructor_assignment.cpp could not be found</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不得不重写的拷贝构造函数]]></title>
    <link href="http://freealvin.github.io/blog/2013/08/17/bu-de-bu-zhong-xie-de-kao-bei-gou-zao-han-shu/"/>
    <updated>2013-08-17T19:39:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/08/17/bu-de-bu-zhong-xie-de-kao-bei-gou-zao-han-shu</id>
    <content type="html"><![CDATA[<pre><code>自定义一个栈类，使用一个栈对象初始化另一个对象，自然会用到拷贝构造函数，代码如下
</code></pre>

<p>File /home/Alvin/git_projects/octopress/source/downloads/code/copy_constructor.cpp could not be found
以上代码在执行的时候会出现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*** glibc detected *** ./a.out: double free or corruption (fasttop)</span></code></pre></td></tr></table></div></figure>


<p>也就是说，我们释放了两次动态分配的空间。为了解决这个问题，我们需要重写拷贝构造函数，在拷贝构造函数中重写申请新对象的动态空间。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Stack(const Stack &t):mem(new T[t.max]), len(t.len), max(t.max){}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Store the Return Value in a Refrence]]></title>
    <link href="http://freealvin.github.io/blog/2013/08/13/store-the-return-value-in-a-refrence/"/>
    <updated>2013-08-13T06:57:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/08/13/store-the-return-value-in-a-refrence</id>
    <content type="html"><![CDATA[<p>  C++中，临时对象生存周期和它被创建时整个语句的生命长度相同，但是我们可以将临时变量赋值给const reference来延长它的生命长度。</p>

<!--more-->


<p>  我在学习C++中的运算符重载时没有注意到这一点，导致编译失败。我的代码是这样写的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Fraction{
</span><span class='line'>  int n;
</span><span class='line'>  int d;
</span><span class='line'>  ……
</span><span class='line'>
</span><span class='line'>  public:
</span><span class='line'>      ……
</span><span class='line'>      Fraction operator+( const Fraction &f2)const;
</span><span class='line'>      friend istream &operator>>(istream &in, Fraction &f);
</span><span class='line'>      friend ostream &operator&lt;&lt;(ostream &out,Fraction &f);
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>Fraction Fraction::operator+( const Fraction &f2)const
</span><span class='line'>{
</span><span class='line'>  Fraction res(n*f2.d + d*f2.n, d*f2.d);
</span><span class='line'>  return res;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//重载>>，以便于输入
</span><span class='line'>istream &operator>>(istream &in , Fraction &f)
</span><span class='line'>{
</span><span class='line'>  char c;
</span><span class='line'>  in>> f.n >> c >> f.d;
</span><span class='line'>  return in;
</span><span class='line'>}
</span><span class='line'>//重载&lt;&lt;，便于输出
</span><span class='line'>ostream &operator&lt;&lt;(ostream &out, Fraction &f)// non-const reference
</span><span class='line'>{
</span><span class='line'>  out&lt;&lt; f.n &lt;&lt; '/' &lt;&lt; f.d;
</span><span class='line'>  return out;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>  Fraction f1;
</span><span class='line'>  Fraction f2;
</span><span class='line'>  cin>>f1>>f2;
</span><span class='line'>  cout&lt;&lt;f1+f2&lt;&lt;endl;//temp f1+f2, operator&lt;&lt;(cout, temp), it's not allowed to bind the temporary value to a non-const reference
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>  在测试重载&lt;&lt;运算符时，输出定义的对象cout&lt;&lt;f1， 没有问题，但当我试着输出cout&lt;&lt;f1+f2时，编译出现了错误</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>error: no match for ‘operator&lt;&lt;’ in ‘std::cout &lt;&lt; operator+(((Fraction&)(& f1)), ((Fraction&)(& f2)))’
</span><span class='line'> note:                 std::ostream& operator&lt;&lt;(std::ostream&, Fraction&)</span></code></pre></td></tr></table></div></figure>


<p>后来查询了资料后，发现是重载&lt;&lt;运算符时，形参的类型导致的。形参f的类型是Fraction &amp;， 而我调用cout&lt;&lt;f1+f2时， f1+f2会调用 f1.operator+(f2)并返回一个临时结果，而错误就出现在这个临时结果上，临时结果是不能改变的，而重载&lt;&lt;时参数的是Fraction &amp;，而不是const Fraction &amp;，而在C++中是不允许把temporary绑定到non-const reference上的，所以编译器会出现以上的错误。</p>

<p>这个练习的所有代码:
File /home/Alvin/git_projects/octopress/source/downloads/code/03operator_overload.cpp could not be found</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Operator Overloading]]></title>
    <link href="http://freealvin.github.io/blog/2013/08/12/c-plus-plus-opeator-overload/"/>
    <updated>2013-08-12T16:42:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/08/12/c-plus-plus-opeator-overload</id>
    <content type="html"><![CDATA[<p>In C++ the overloading principle applies not only to functions, but to operators too. That is, of operators can be extended to work not just with built-in types but also classes. A programmer can provide his or her own operator to a class by overloading the built-in operator to perform some specific computation when the operator is used on objects of that class.</p>

<!--more-->


<h2>An example of operator overloading</h2>


<p>File /home/Alvin/git_projects/octopress/source/downloads/code/03operator_overload.cpp could not be found</p>

<p>In order to allow operations like cin>>f, in above code we overloaded the &ldquo;>>&#8221;operator. And in order to access the private memebers in the implementations, we use keyworkd &#8220;friend&rdquo;.A important trick that can be seen in this general way of overloading IO is the returning reference for istream/ostream which is needed in order to use them in a recursive manner:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cin>>f1>>f2;</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Determine if Two Binary Trees Are Equal]]></title>
    <link href="http://freealvin.github.io/blog/2013/08/10/determine-if-two-binary-trees-are-equal/"/>
    <updated>2013-08-10T21:21:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/08/10/determine-if-two-binary-trees-are-equal</id>
    <content type="html"><![CDATA[<p>What would be the efficient algorithm to find if two given binary trees are equal &ndash; in structure and content?</p>

<!--more-->


<p>File /home/Alvin/git_projects/octopress/source/downloads/code/binary_tree_equal.c could not be found</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test Chinese Fonts]]></title>
    <link href="http://freealvin.github.io/blog/2013/08/10/test-chinese-fonts/"/>
    <updated>2013-08-10T20:58:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/08/10/test-chinese-fonts</id>
    <content type="html"><![CDATA[<p>解决CentOS中文显示问题：
一：安装中文支持</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># yum install "@Chinese Support"</span></code></pre></td></tr></table></div></figure>


<p>二：安装字体</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># yum install fonts-chinese.noarch</span></code></pre></td></tr></table></div></figure>


<p>三：修改配置文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># vi /etc/sysconfig/i18n</span></code></pre></td></tr></table></div></figure>


<p>将</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LANG="en_US.UTF-8" 
</span><span class='line'>SYSFONT="latarcyrheb-sun16"</span></code></pre></td></tr></table></div></figure>


<p>修改为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LANG="zh_CN.GB18030" 
</span><span class='line'>LANGUAGE="zh_CN.GB18030:zh_CN.GB2312:zh_CN" 
</span><span class='line'>SUPPORTED="zh_CN.UTF-8:zh_CN:zh:en_US.UTF-8:en_US:en" 
</span><span class='line'>SYSFONT="lat0-sun16"</span></code></pre></td></tr></table></div></figure>


<p>四：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># cd /usr/share/fonts/
</span><span class='line'># fc-cache   -fv</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Recreate a Local Repository of Octopress Blog]]></title>
    <link href="http://freealvin.github.io/blog/2013/08/10/recreate-a-local-responsitory-of-octopress-blog/"/>
    <updated>2013-08-10T19:04:00+08:00</updated>
    <id>http://freealvin.github.io/blog/2013/08/10/recreate-a-local-responsitory-of-octopress-blog</id>
    <content type="html"><![CDATA[<!--more-->


<h2>Recreating a local Octopress repository </h2>


<p>To recreate the local directory structure of an existing Octopress blog, follow these instructions.</p>

<h2>Clone your blog to the new machine</h2>


<p>First you need to clone the source branch to the local octopress folder.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git clone -b source git@github.com:username/username.github.com.git octopress</span></code></pre></td></tr></table></div></figure>


<p>Then clone the master branch to the _deploy subfolder.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd octopress
</span><span class='line'>$ git clone git@github.com:username/username.github.com.git _deploy</span></code></pre></td></tr></table></div></figure>


<p>Then run the rake installation to configure everything</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem install bundler
</span><span class='line'>$ rbenv rehash
</span><span class='line'>$ bundle install
</span><span class='line'>$ rake setup_github_pages</span></code></pre></td></tr></table></div></figure>




<h2> Pushing changes from two different machines</h2>


<p>If you want to blog from more than one computer, you need to make sure that you push everything before switching computers. From the first machine do the following whenever you’ve made changes:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rake generate
</span><span class='line'>$ git add .
</span><span class='line'>$ git commit -am "Some comment here." 
</span><span class='line'>$ git push origin source  # update the remote source branch 
</span><span class='line'>$ rake deploy             # update the remote master branch</span></code></pre></td></tr></table></div></figure>


<p>Then on the other machine, you need to pull those changes.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd octopress
</span><span class='line'>$ git pull origin source  # update the local source branch
</span><span class='line'>$ cd ./_deploy
</span><span class='line'>$ git pull origin master  # update the local master branch</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
</feed>
